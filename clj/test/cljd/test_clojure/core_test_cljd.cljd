;   Copyright (c) Baptiste Dupuch & Christophe Grand. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

;;  Tests for ClojureDart (not copied from clj/cljs code base)
;;

(ns cljd.test-clojure.core-test-cljd
  (:require ["dart:async" :as dart:async]
            ["dart:developer" :as dev]
            ["dart:io" :as io]
            ["dart:typed_data" :as typed-data]
            [cljd.string :as str])
  (:use [cljd.test :only [deftest is testing are]]))

(deftest testing-rseq
  (testing "Testing rseq function"
    (is (= '(4 3 2 1) (rseq [1 2 3 4])))
    (is (nil? (first (rseq []))))
    (is (= (rseq (first {:a :b})) [:b :a]))
    (is (= 9 (reduce (fn [acc x] (if (= 1 x) (reduced acc) (+ acc x))) 0 (rseq (vec (range 5))))))
    (is (= '(3 2 1) (rseq (subvec [0 1 2 3] 1))))
    (is (nil? (meta (rseq (with-meta [1] {:a :b})))))
    (is (= (meta (with-meta (rseq [1 2 3]) {:a :b})) {:a :b}))
    (is (= (rseq (vec (range 100))) (range 99 -1 -1)))
    (is (= (rseq (subvec (vec (range 100)) 33 42)) (range 41 32 -1)))))

(deftest testing-dart-literal-typehints
  (testing "#dart[] List are typehints"
    (is (dart/is? #dart[1 2] #/(List dynamic)))
    (is (dart/is? #dart ^int [1 2] #/(List int)))
    (is (not (dart/is? #dart ^int [1 2] #/(List String))))
    (is (dart/is? #dart ^:fixed ^int [1 2] #/(List int)))
    (let [a #dart ^int [1 2]
          b a
          c b
          d c]
      (is (dart/is? d #/(List int))))))

(deftest testing-if-typehints
  (testing "if typehints"
    (let [a (if (odd? 3) true false)]
      (is (dart/is? a bool)))
    (let [a (when (odd? 3) true false)]
      (is (dart/is? a bool?)))
    (let [a (if (odd? 3) 3 4)]
      (is (dart/is? a int)))
    (let [a (if (odd? 3) 3 nil)]
      (is (dart/is? a int?)))
    (let [a (if (odd? 3) 3 4.3)]
      (is (dart/is? a dynamic)))
    (let [a (when-let [a (if (odd? 3) 3 4)] a)]
      (is (dart/is? a int?)))
    (let [a (if (odd? 2) (throw (Exception. "exception")) "aa")]
      (is (dart/is? a String)))
    (let [a (if (odd? 2) nil nil)]
      (is (dart/is? a Null)))))

(deftest testing-loop-typehints
  (testing "loop typehints"
    (let [a (loop [i 0] (if (< i 10) (recur (inc i)) "a"))]
      (is (dart/is? a String)))
    (let [a (loop [i 0] (if (< i 10) (recur (inc i)) 1))]
      (is (dart/is? a int)))
    (let [a (loop [i 0] (if (< i 10) (recur (inc i)) ^dynamic (do 1)))]
      (is (dart/is? a dynamic)))))

(deftest testing-inline-fn-typehints
  (testing "inline fn typehints"
    (let [a (fn [] 1)]
      (is (dart/is? a #/( -> int)))) ;; int Function()
    (let [b ^:async (fn [] 1)]
      (is (dart/is? b  #/( -> (Future int)))))
    (let [c ^:async (fn [a] (if (odd? a) 3 4))]
      (is (dart/is? c #/(dynamic -> (Future int)))))
    (let [d ^:async (fn nom [a] (if (odd? a) (nom (inc a)) 4))]
      (is (dart/is? d #/(dynamic -> (Future int)))))
    (let [e ^:async (fn ^num nom [a] (if (odd? a) (nom (inc a)) 4))]
      (is (dart/is? e #/(dynamic -> (Future num)))))
    (let [f (fn ^dart:core/Never nom [] (nom))]
      (is (dart/is? f #/( -> dart:core/Never))))
    (let [g (fn nom [] (nom))]
      (is (dart/is? g #/( -> dynamic))))
    (let [h (fn [] nil)]
      (is (dart/is? h #/( -> Null))))
    (let [i ^:async (fn [] nil)]
      (is (dart/is? i #/( -> (Future Null)))))))

(deftest testing-local-fn-typehints
  (testing "inline fn typehints"
    (let [a (fn [] 1)
          a' a]
      (is (dart/is? a' #/( -> int))))
    (let [b ^:async (fn [] 1)
          b' b]
      (is (dart/is? b'  #/( -> (Future int)))))
    (let [c ^:async (fn [a] (if (odd? a) 3 4))
          c' c]
      (is (dart/is? c' #/(dynamic -> (Future int)))))
    (let [d ^:async (fn nom [a] (if (odd? a) (nom (inc a)) 4))
          d' d]
      (is (dart/is? d' #/(dynamic -> (Future int)))))
    (let [e ^:async (fn ^num nom [a] (if (odd? a) (nom (inc a)) 4))
          e' e]
      (is (dart/is? e' #/(dynamic -> (Future num)))))
    (let [f (fn ^dart:core/Never nom [] (nom))
          f' f]
      (is (dart/is? f' #/( -> dart:core/Never))))
    (let [g (fn nom [] (nom))
          g' g]
      (is (dart/is? g' #/( -> dynamic))))
    (let [h (fn [] nil)
          h' h]
      (is (dart/is? h' #/( -> Null))))
    (let [i ^:async (fn [] nil)
          i' i]
      (is (dart/is? i' #/( -> (Future Null)))))))

(deftest testing-dart-new-dont-need-to-be-lifted
  (testing "dart/new can be inlined"
    (is (dart/is?
          #dart ^Symbol [(dart:core/Symbol. "one") (dart:core/Symbol. "two") (dart:core/Symbol. "three")]
          #/(List Symbol)))
    (is (dart/is?
          #dart ^Symbol [(dart:core/Symbol. "one") (dart:core/Symbol. (let [a "a" b "b"] (str a b)))]
          #/(List Symbol)))))

(def baptiste {:first-name "Baptiste" :last-name "Dupuch"})

(deftest testing-keys-and-vals
  (is (= #{:first-name :last-name} (into #{} (keys baptiste))))
  (is (= #{"Baptiste" "Dupuch"} (into #{} (vals baptiste))))
  (is (= #{:first-name :last-name} (into #{} (keys (vec baptiste)))))
  (is (= #{"Baptiste" "Dupuch"} (into #{} (vals (vec baptiste)))))
  (is (= :a (first (keys (cons (first {:a :b}) (range 10)))))))

(deftest testing-cycle
  (is (= () (cycle nil)))
  (is (= () (cycle [])))
  (is (= '(1 2 3 1 2 3 1 2 3) (take 9 (cycle [1 2 3])))))

(deftest testing-gensym
  (is (= ":love" (namespace (gensym :love/cljd))))
  (is (= "love" (namespace (gensym 'love/cljd))))
  (is (= "love" (namespace (gensym "love/cljd")))))

(deftest testing-int-array
  (is (= (seq #dart [0 0 0]) (seq (int-array 3))))
  (is (dart/is? (int-array 3) #/(List int)))
  (is (= (seq #dart [0 1 2]) (seq (int-array (range 3)))))
  (is (dart/is? (int-array (range 3)) #/(List int)))

  (is (= (seq #dart [0 1 2 0 0]) (seq (int-array 5 (range 3)))))
  (is (dart/is? (int-array 5 (range 3)) #/(List int)))
  (is (= (seq #dart [4 4 4 4 4]) (seq (int-array 5 4))))
  (is (dart/is? (int-array 5 4) #/(List int))))

(deftest testing-amap
  (let [an-array (int-array 3 3)]
    (is (= (seq [4 4 4])
          (seq (amap an-array
                 idx
                 ret
                 (inc (aget an-array idx))))))))

(deftest testing-areduce
  (let [an-array (int-array 3 3)]
    (is (= 9
          (areduce an-array i ret 0
            (+ ret (aget an-array i)))))))

(deftest testing-casting
  (is (dart/is? (ints #dart[1 2 3]) #/(List int)))
  (is (dart/is? (booleans #dart[true false]) #/(List bool))))

(defrecord EmptyRecord [])

(deftest testing-empty-record
  (is (= (hash (->EmptyRecord)) (hash (->EmptyRecord))))
  (is (dart/is? (-> (->EmptyRecord) (. #/(cast int int))) #/(EmptyRecord int int)))
  (is (= (for [[k v] (assoc (->EmptyRecord) :a :b :c :d :e :f)]
           k)
        '(:a :c :e))))

(defrecord RecordA [a]
  (mymethod [this] (str a "two")))

(deftest testing-recorda
  (is (= "onetwo" (.mymethod (->RecordA "one"))))
  (is (= {:a :b} (meta (with-meta (->RecordA "one") {:a :b})))))

(deftest testing-bounded-count
  (is (= 4 (bounded-count 5 [1 2 3 4])))
  (is (= 5 (bounded-count 5 [1 2 3 4 5])))
  (is (= 6 (bounded-count 5 [1 2 3 4 5 6])))
  (is (= 4 (bounded-count 5 (map identity [1 2 3 4]))))
  (is (= 5 (bounded-count 5 (map identity [1 2 3 4 5]))))
  (is (= 5 (bounded-count 5 (map identity [1 2 3 4 5 6]))))
  (is (= 5 (bounded-count 5 (range))))
  (is (= 2 (bounded-count 1.5 (range)))))

(deftest testing-distinct?
  (is (= true (distinct? 1)))
  (is (= false (distinct? 1 1)))
  (is (= true (apply distinct? (range 20)))))

(deftest testing-every-pred
  (is (= true ((every-pred #(< % 10) number?) 1 2 3 4))))

(deftest testing-filterv
  (is (= [1 3 5 7 9] (filterv odd? (range 10)))))

(deftest testing-frequencies
  (is (= {1 3 "a" 1} (frequencies [1 "a" 1 1]))))

(deftest testing-group-by
  (is (= {false [0 2 4 6 8], true [1 3 5 7 9]} (group-by odd? (range 10)))))

(deftest testing-mapv
  (is (= [0 2 4 6 8] (mapv + (range 5) (range 5)))))

(deftest testing-reset-meta!
  (is (= {:c :d} (let [a (atom {} :meta {:a :b})]
                   (reset-meta! a {:c :d})))))

(deftest testing-select-keys
  (is (= {1 1 5 5} (select-keys (into {} (map #(vector % %)) (range 10)) [1 5]))))

(deftype Base [x]
  Object
  (toString [_] (str "Base of " x)))

(deftest testing-reify-with-extends
  (is (== "Base of weird-reify"
        (str (reify
               :extends (Base. "weird-reify"))))))

(definterface IRecordExtends
  (^String? mymethod []))

(defrecord RecordExtends [a]
  :extends (cljd.core/Atom. nil nil nil {})
  IRecordExtends
  (mymethod [this] (str a "two")))

(deftest testing-extends-on-records
  (is (= "onetwo" (.mymethod (->RecordExtends "one"))))
  (is (dart/is? (->RecordExtends "one") cljd.core/Atom)))

(deftest testing-subvec-issue-23
  (is (= [4 5]
        (-> [1 2 3 4 5 6 7]
          (subvec 1)
          (subvec 1)
          (subvec 1 3)))))

(deftest testing-dart-map-comply-with-iseqable-ilookup
  (let [dart-map (Map/fromEntries (. ^List (seq {:a :b }) #/(cast MapEntry)))]
    (is (= :b (get dart-map :a)))
    (is (true? (contains? dart-map :a)))
    (is (false? (contains? dart-map :e)))
    (is (= {:a :b} (into {} dart-map)))))

(deftest testing-dart-mapentry-comply-with-imapentry-iidexed
  (let [dart-map (Map/fromEntries (. ^List (seq {:a :b }) #/(cast MapEntry)))
        me (first dart-map)]
    (is (= :a (nth me 0)))
    (is (= :b (nth me 1)))
    (is (= 2 (count me)))
    (is (= :a (key me)))
    (is (= :b (val me)))
    (is (= {:a :b} (into {} [me])))))

(deftest testing-map-entry-should-be-cast-if-map-are-casted
  (let [original {"aa" 4 "bb" 5}
        casted-map (. original #/(cast String int))]
    (is (false? (dart/is? original #/(cljd.core/PersistentHashMap String int))))
    (is (true? (dart/is? original #/(cljd.core/PersistentHashMap dynamic dynamic))))
    (is (false? (dart/is? (first original) #/(MapEntry String int))))

    (is (true? (dart/is? casted-map #/(cljd.core/PersistentHashMap String int))))
    (is (true? (dart/is? (first casted-map) #/(MapEntry String int))))

    (is (false? (dart/is? (find [0 1 2] 1) #/(MapEntry int int))))
    (is (true? (dart/is? (find (. [0 1 2] #/(cast int)) 1) #/(MapEntry int int))))

    (is (false? (dart/is? (find (subvec [0 1 2] 1) 1) #/(MapEntry int int))))
    (is (true? (dart/is? (find (. ^List (subvec [0 1 2] 1) #/(cast int)) 1) #/(MapEntry int int))))

    (is (false? (dart/is? (find {"a" "b"} "a") #/(MapEntry String String))))
    (is (true? (dart/is? (find (. {"a" "b"} #/(cast String String)) "a") #/(MapEntry String String))))))

(deftest colls-are-equal-for-dart
  (let [ma {:a 1}
        mb (assoc {} :a 1)
        va [1]
        vb (conj [] 1)
        sa #{1}
        sb (conj #{} 1)]
    (is (.== ma mb))
    (is (not (identical? ma mb)))
    (is (.== va vb))
    (is (not (identical? va vb)))
    (is (.== sa sb))
    (is (not (identical? sa sb)))))

(deftest vars-dont-shadow-aliases
  (is (= "ab" (str/join ["a" "b"])))
  (is (= "1" (str 1))))

(deftest closed-overs-hinted-arguments
  ; https://clojurians.slack.com/archives/C03A6GE8D32/p1651592868443379
  (let [f (fn [^String oops] (reify Object (toString [this] oops)))]
    (is (= "abc" (str (f "abc"))))))

(deftest named-const-constructors-GH53
  (is (not (identical? ^:unique (Iterable/empty) (Iterable/empty))))
  (is (identical? (Iterable/empty) (Iterable/empty))))

(deftest parent-this-capture
  (let [x (reify Object
            (toString [outer-this]
              (str "+" (reify Object
                         (toString [inner-this]
                           (str (.-hashCode outer-this)))))))]
    (is (= (str "+" (.-hashCode x)) (.toString x)))))

(deftest super-pseudo-type
  (let [x (reify Object
            (hashCode [_] 42)
            (toString [self] (str (.-hashCode ^super self))))]
    (is (= (str (dart:core/identityHashCode x)) (str x)))
    (is (= 42 (.-hashCode x)))))


(deftest closing-over-super
  (let [v (volatile! nil)
        x (reify Object
            (hashCode [this]
              (vreset! v #(.-hashCode ^super this))
              42))
        y (reify Object
            (hashCode [that]
              (vreset! v
                (reify Object
                  (hashCode [this]
                    (bit-xor (.-hashCode ^super that) (.-hashCode ^super this)))))
              43))]
    (is (= 42 (.-hashCode x)))
    (is (= (dart:core/identityHashCode x) (@v)))
    (is (= 43 (.-hashCode y)))
    (is (= (bit-xor (dart:core/identityHashCode y)
             (dart:core/identityHashCode @v))
          (.-hashCode @v)))))

(deftype InferredAwait [^#/(Future int) prop]
  (coucou [this] (await prop)))

(deftype NotInferredAwait [^#/(Future int) prop]
  (^:async coucou [this] (await prop)))

(definterface ConcreteInterface (^#/(Future int) mymethod []))

(deftype Concrete []
  ConcreteInterface
  (mymethod [this] (await (Future/value 42))))

(deftest await-inference
  (let [num (.value #/(Future int) 42)]
    (is (= (await (.coucou (InferredAwait. num)))
          (await (.coucou (NotInferredAwait. num)))))
    (is (= (inc (await (.coucou (InferredAwait. num))))
          (await ((fn [& more] (inc (await (first more)))) num))
          43))
    (is (= 42 (.-hashCode (reify Object
                           (hashCode [this] ((fn ([] 42) ([one] (await one)))))))))
    (is (= 42 (let [x (await (.mymethod (Concrete.)))] x)))))

;; this case happened with dev.ServiceExtensionResponse/result
(deftest infer-named-constructor-when-same-name-prop-exists
  (let [ser (dev.ServiceExtensionResponse/result "coucou")]
    (is (dart/is? ser dev/ServiceExtensionResponse))
    (is (dart/is? (.-result ser) String?))))

(definterface INullableFunctionBug
  (^String text [^^{:fn-type {:ret-type void}} Function? onPressed]))

(deftype NullableFunctionBug []
  INullableFunctionBug
  (text [this ^^{:fn-type {:ret-type void}} Function? onPressed]
    (if-not (nil? onPressed)
      (do (onPressed)
          "hooo")
      "Heeyyy")))

(deftest nullable-function-bug
  (let [x (NullableFunctionBug.)]
    (fn [] "aa" nil)
    (is (= "Heeyyy" (.text x nil)))
    (is (= "hooo" (.text x (fn [] "dd" nil))))))

(deftest CLJD-74-assoc!-subnode
  (let [m '{tiltontec.util.base/*trdeep* 5 tiltontec.cell.base/*call-stack* 7}
        m' (persistent! (assoc! (transient m) 'tiltontec.util.base/*trdeep* 50))]
    (is (= (count m) (count m')))))

(deftest CLJD-77-first-on-subvec
  (let [v (into [] (range 100))]
    (is (= 1 (first (subvec v 1))))))

(deftest CLJD-76-case-on-symbols
  (is (= true (case 'x x true false)))
  (is (= false (case 'y x true false))))

(definterface ICastNullable
  (^String text [^#/(List? String) actions]))

(deftype CastNullable [useless]
  ICastNullable
  (text [this actions]
    (if-not (nil? actions)
      (.-last actions)
      "worked")))

(deftest cast-nullable-to-non-nullable-for-castable-collections
  (let [x (CastNullable. nil)]
    (is (= "clojuredart" (.text x (cond-> ["coucou"]
                                    true (conj "clojuredart")))))
    (is (= "worked" (.text x nil)))
    (is (= "worked" (.text x ^List? (identity nil))))))

(deftest no-core-private-lib-exposed-by-compilation
  ; it's a compile time "test": if it compiles it's ok
  (let [s (fn []
            (let [server (await (.bind io/HttpServer (.-anyIPv6 io/InternetAddress) 8080))]
              (.forEach server (fn [^io/HttpRequest r]
                                 (.close (.-response r))
                                 nil))))]
    ;; here we only test compilation works
    (is (some? s))))

(deftest CLJD-101-cast-them-all
  (let [path ["first" "second"]]
    (is (some?
          (Uri.
            .path (when (string? path) path)
            .pathSegments (when (coll? path) path))))))

(deftest dart-apply
  (is (false?
        (Function/apply dart:core/identical ["hello" "world"] {}))))

(deftest CLJD-96-destructure-test
  (let [sample-destructure-test (fn [& {:keys [foo]}] foo)]
    (testing "Destructuring in many ways"
      (is (nil? (sample-destructure-test)))
      (is (zero? (sample-destructure-test :foo 0)))
      (is (zero? (sample-destructure-test :foo 1 :foo 0)))
      (is (nil? (sample-destructure-test :bar 1))))))

(deftest casting-to-double
  (is (= 1.0 (first #dart ^double [1.0])))
  (is (= 1.0 (first #dart ^double [1])))
  (is (= 1.0 (first #dart ^double [(identity 1)]))))

;; see https://github.com/Tensegritics/ClojureDart/issues/112
(definterface IIssue112
  (^String? positionalopts [^String one ... ^int? two
                            ^^{:fn-type {:ret-type String
                                         :fixed-params-types (String String)}} Function? three])
  (^String? namedopts [^String one ^int? .two
                       ^^{:fn-type {:ret-type String
                                    :fixed-params-types (String String)}} Function? .three]))

(deftype ConcreteIssue112 []
  IIssue112
  (positionalopts [this one ... two three] (when three (three "one" "two")))
  (namedopts [this one .two .three] (when three (three "one" "two"))))

(deftest opt-named-pos-param-type-inference-github-11
  (let [rei (reify :no-meta true
              IIssue112
              (positionalopts [this one ... two three] (when three (three "one" "two")))
              (namedopts [this one .two .three] (when three (three "one" "two"))))
        concrete (ConcreteIssue112)]
    (is (= "onetwo" (.positionalopts rei "one" 2 (fn [a b] (str a b)))))
    (is (= "onetwo" (.namedopts rei "one" .three (fn [a b] (str a b)))))
    (is (= "onetwo" (.positionalopts concrete "one" 2 (fn [a b] (str a b)))))
    (is (= "onetwo" (.namedopts concrete "one" .three (fn [a b] (str a b)))))))

(deftest close-over-values-not-slots
  (let [fs (loop [fs [] i 4]
             (if (neg? i)
               fs
               (recur (conj fs (fn [] i)) (dec i))))]
    (is (= [4 3 2 1 0] (map (fn [f] (f)) fs)))))

(deftest resulting-type-arg-nullable-iff-input-type-arg-nullable-and-param-null
  (let [m {"color" "red"}
        m (. m #/(cast String String?))]
    (is (= true (dart/is? m #/(Map String String?))))))

(deftest seq?-nil-is-false-CLJD137
  (is (= false (seq? nil))))

(defrecord RecordWithMungedFields [to-test!])

(deftest records-equiv-work-with-munged-fields-CLJD135
  (is (= (->RecordWithMungedFields 42) (->RecordWithMungedFields 42)))
  (is (not= (->RecordWithMungedFields 42) (->RecordWithMungedFields 33))))

(deftest lifted-letfn-CLJD141
  (is (= 2 (apply (letfn [(f [x] (inc x))] f) 1 nil)))
  (is (= [:f :g :f :g]
        (letfn [(g [n] (when (pos? n) (cons :g (f (dec n)))))
                (f [n] (when (pos? n) (cons :f (g (dec n)))))]
          ((identity f) 4)))))

(deftest toDoublePushedToLeaves-CLJD142
  (is (= 0 (identity ^double (if (< 1 2) 0 0))))
  (is (nil? (identity ^double? (if (< 1 2) nil 0)))))

(deftype Const1 [])
(deftype Const2 [] :extends Const1)

(deftest properly-infer-const-when-ancestor-is-not-Object
  (is (identical? (Const2) (Const2))))

(deftype Const3 [x])

(deftest const-locals-inference-CLJD145
  (let [s "coucou"]
    (is (identical? (Const3 s) (Const3 "coucou")))
    (is (identical? (Const3 s) (Const3 s)))))

(deftest stream-xform-tests
  (let [coll (range 10)
        xform (comp (map inc) (filter odd?) (halt-when #(< 7 %)))
        error-xform (map (fn [[er st]]
                           [(ArgumentError "bordeaux is magic")
                            (StackTrace/fromString "stacktrace")]))]
    (is (dart/is? (stream coll) dart:core/Stream))
    (is (= (into [] (-> (stream xform coll) .toList await)) [1 3 5 7]))
    (is (= (into [] (-> (stream xform error-xform coll) .toList await)) [1 3 5 7]))
    (is (thrown? ArgumentError (-> (stream xform error-xform (Stream/error :error)) .toList await)))
    (is (thrown-with-msg?
          ArgumentError
          #"bordeaux is magic"
          (-> (stream xform error-xform (Stream/error :error)) .toList await)))
    (is (= (into [] (-> (stream xform (map first) :as-values (Stream/error :error)) .toList await))
          [:error]))))

;; (.fold (stream xform coll) [] (fn [acc item] (conj acc item)))

(deftest meta-on-colls-not-generated-CLJD151
  (is (= (meta '^{x (inc 1)} [1]) '{x (inc 1)}))
  (is (= ((fn [] (meta '^{x (inc 1)} [1]))) '{x (inc 1)}))
  (is (= (meta ^{:a (inc 1)} [1]) {:a 2}))
  (is (= ((fn [] (meta ^{:a (inc 1)} [1]))) {:a 2}))

  (is (= (meta '^{x (inc 1)} []) '{x (inc 1)}))
  (is (= ((fn [] (meta '^{x (inc 1)} []))) '{x (inc 1)}))
  (is (= (meta ^{:a (inc 1)} []) {:a 2}))
  (is (= ((fn [] (meta ^{:a (inc 1)} []))) {:a 2})))

(defprotocol IDestructuringProto
  (-destructured [a b]))

(defprotocol IDestructuringProto2
  (-destructured2 [a b]))

(defprotocol IDestructuringProto3
  (-destructured3 [a b]))

(defprotocol INotDestructuringProto
  (-not-destructured [a b]))

(definterface INotDestructuringInterfaceWithOpts
  (^num notdestructured [one ... ^int? two]))

(deftype DestructuringProto []
  INotDestructuringInterfaceWithOpts
  (^num notdestructured [this {:keys [a b]} ... ^num? two] (+ two a b))
  IDestructuringProto
  (-destructured [_ {:keys [a b c]}] [a b c]))

(extend-type DestructuringProto
  IDestructuringProto2
  (-destructured2 [_ {:strs [a b c]}] [a b c])
  INotDestructuringProto
  (-not-destructured [a b] b))

(extend-protocol IDestructuringProto3
  DestructuringProto
  (-destructured3 [_ {:syms [a b c]}] [a b c]))

(deftest destructuring-for-deftype
  (is (= 6 (.notdestructured (DestructuringProto.) {:a 1 :b 2 :c 3} 3)))
  (is (= [1 2 3] (-destructured (DestructuringProto.) {:a 1 :b 2 :c 3})))
  (is (= [1 2 3] (-destructured2 (DestructuringProto.) {"a" 1 "b" 2 "c" 3})))
  (is (= [1 2 3] (-destructured3 (DestructuringProto.) '{a 1 b 2 c 3})))
  (is (= {:a 1 :b 2 :c 3} (-not-destructured (DestructuringProto.) {:a 1 :b 2 :c 3}))))

(deftest test-abs
  (are [in ex] (= ex (abs in))
    -1 1
    1 1
    #_#_Long/MIN_VALUE Long/MIN_VALUE ;; special case!
    -1.0 1.0
    -0.0 0.0
    #_#_##-Inf ##Inf
    #_#_##Inf ##Inf
    -123.456M 123.456M
    -123N 123N
    -1/5 1/5)
  #_(is (NaN? (abs ##NaN))))

(deftest closed-over-consts-in-reify
  (let [s "name"
        f (fn ([] (Symbol s)) ([_] nil))]
    (is (identical? (Symbol s) (f)))))

(deftest unary-minus-wrong-priority
  ;; don't inline `m` as test will pass no matter what
  (let [m {:num 10.2}]
    (is (= "-10.20" (.toStringAsFixed (- ^num (:num m)) 2)))))

(deftest new-setter-sugar
  (let [{:flds [name value]} (doto (io/Cookie "name" "value")
                               (.-name! "newname")
                               (.-value! "newvalue"))]
    (is (= name "newname"))
    (is (= value "newvalue"))))

(deftest positive-type-safe-if-some
  (is (nil? (when-some [{finite .-isFinite} ^num (identity nil)] 1 2)))
  (is (= 2 (if-some [{finite .-isFinite} ^num (identity nil)] 1 2))))

(deftest future-macro
  (is (= :ok (await (future :ok))))
  (is (= 2
        (let [df (Future/value 1)]
          (await (future (inc (await df))))))))

(deftype NullableFutureType []
  (^#/(Future? (List int)) ^:async hey [this i]
   (if (odd? i)
     #dart ^int ^:fixed [1 2]
     (throw (Exception "thrown")))))

(deftest await-propagate-nullable-future
  (is (= 1 (.-first (await (.hey (NullableFutureType) 1)))))
  (is (thrown? Exception (await (.hey (NullableFutureType) 2)))))

(deftest some-tests-for-nil
  ; the = true/false are there to allow inlining to work in the expression under test
  (is (= true (some? 12)))
  (is (= false (some? nil)))
  (is (= false (some? (seq []))))
  (is (= false (some? (:k {:x 2})))))

(deftype ExtendTypeWorkingOnMultipleNs [])

(deftype ExtendTypeWorkingOnMultipleNs2 [])

(extend-protocol cljd.core/IPrint
  ExtendTypeWorkingOnMultipleNs
  (-print [_ a]
    (.write ^Sink a "ohoh"))
  ExtendTypeWorkingOnMultipleNs2
  (-print [_ a]
    (.write ^Sink a "ahah")))

(deftest extend-type-multiple-ns
  (is (= (with-out-str (prn (ExtendTypeWorkingOnMultipleNs)) "ohoh")))
  (is (= (with-out-str (prn (ExtendTypeWorkingOnMultipleNs2)) "ahah"))))

(deftest treap
  (let [m (sorted-map)
        m100 (into m (map (juxt str identity)) (range 100))
        dump (fn dump [^cljd.core/TreapNode n rank]
               (if (zero? rank)
                 (vec (.-arr n))
                 (into [] (map-indexed (fn [i x] (if (even? i) (dump x (dec rank)) x))) (.-arr n))))]
    #_(let [v100 (into [] (range 100))
          hm100 (into {} (map (juxt str identity)) (range 100))]
         (quick-bench (reduce-kv (fn [n _ v] (+ n v)) 0 m100))
         (quick-bench (reduce-kv (fn [n _ v] (+ n v)) 0 hm100))
         (quick-bench (reduce (fn [n v] (+ n v)) 0 v100)))

    #_(prn (dump (.-root m100) (.-top_rank m100)))
    (is (= 1 (-> m (assoc "k" 1) (get "k"))))
    (is (nil? (-> m (assoc "k" 1) (get "j"))))
    (is (= 42 (-> m (assoc "k" 1) (get "j" 42))))
    (is (every? #(= (m100 (str %)) %) (range 100)))
    (doseq [[args res] {["9" nil 12] [["9" 9] ["90" 90] ["91" 91] ["92" 92] ["93" 93] ["94" 94] ["95" 95] ["96" 96] ["97" 97] ["98" 98] ["99" 99]]
                        ["9 " nil 12] [["90" 90] ["91" 91] ["92" 92] ["93" 93] ["94" 94] ["95" 95] ["96" 96] ["97" 97] ["98" 98] ["99" 99]]
                        ["8" "9" 14] [["8" 8] ["80" 80] ["81" 81] ["82" 82] ["83" 83] ["84" 84] ["85" 85] ["86" 86] ["87" 87] ["88" 88] ["89" 89]]
                        ["8" "9" 15] [["8" 8] ["80" 80] ["81" 81] ["82" 82] ["83" 83] ["84" 84] ["85" 85] ["86" 86] ["87" 87] ["88" 88] ["89" 89] ["9" 9]]
                        ["8" "9" 11] [["80" 80] ["81" 81] ["82" 82] ["83" 83] ["84" 84] ["85" 85] ["86" 86] ["87" 87] ["88" 88] ["89" 89] ["9" 9]]
                        [nil "2" 2] [["0" 0] ["1" 1] ["10" 10] ["11" 11] ["12" 12] ["13" 13] ["14" 14] ["15" 15] ["16" 16] ["17" 17] ["18" 18] ["19" 19]]
                        [nil "111" 3] [["0" 0] ["1" 1] ["10" 10] ["11" 11]]}]
      (is (= res (apply -sorted-seq m100 args)))
      (is (= (rseq res) (apply -sorted-rseq m100 args))))))

(deftest weird-cmp-treap
  (let [m (sorted-map-by (fn [a b] (compare (subs a 1) (subs b 1))))
        N 1000
        mN (into m (map (juxt str identity)) (range N))
        expected-vs (into {} (map (fn [n] [(subs (str n) 1) n])) (range N))
        dump (fn dump [^cljd.core/TreapNode n rank]
               (if (zero? rank)
                 (vec (.-arr n))
                 (into [] (map-indexed (fn [i x] (if (even? i) (dump x (dec rank)) x))) (.-arr n))))]
    #_(prn (dump (.-root mN) (.-top_rank mN)))
    (is (every? #(= (mN (str %)) (expected-vs (subs (str %) 1))) (range N)))
    (is (= (seq mN) (map (juxt str identity) (vals (sort expected-vs)))))))

(deftest sorting-work-normally-with-boolean-comp
  (is (= [32 23 9] (sort > [23 32 9])))
  (is (= [9 23 32] (sort < [23 32 9]))))

(deftest chunked-pv-seq-was-going-straight-to-the-tail-after-first-chunk
  (is (= (range 65) (map identity (into [] (range 65))))))

(deftest tear-off-support
  (is (fn? (.-allMatches ""))))

(deftest transient-set-CLJD217
  (let [l [nil 0 2.0 "~eight" 1 true "five" false 'seven :six]]
    (is (= (reduce conj #{} l)
          (persistent! (reduce conj! (transient #{}) l))))))

(deftest compiler-and-runtime-agree-on-hash
  (is (= (hash :left) (hash (keyword "left")))))

(deftest chunked-seq-of-64-item-vector
  (is (= (repeat 64 nil) (reduce conj [] (repeat 64 nil)))))

(deftest default-constructor-tear-off
  (is (= (Symbol "hello") (Function.apply Symbol.new ["hello"] {}))))

(deftest map-entries-equiv
  (is (= [0 1] (MapEntry 0 1)))
  (is (= (MapEntry 0 1) [0 1]))
  (is (= ^:unique (MapEntry 0 1) ^:unique (MapEntry 0 1))))

(deftest no-short-circuiting-in-statement-position
  (let [f (fn [n]
            (let [a (atom 0)]
              (cond
                (= 1 n) (swap! a inc)
                (= 1 n) (throw (Exception. "thrown"))
                :else (swap! a inc))
              @a))]
    (is (= 1 (f 1)))))

(deftest constructor-as-set-target
  ; ensures that all targets are lifted unless they are dart/as
  ; it's mostly a compile-time test as this expression used to crash the cmpiler
  (is (= 1.0 (.-last! (typed-data/Float32List 63) 1.0))))

(deftest rseq-on-vectors-whose-length-is-a-multiple-of-32
  (is (= (range 31 -1 -1) (rseq (vec (range 32)))))
  (is (= (range 63 -1 -1) (rseq (vec (range 64))))))

(deftest atom-can-be-used-in-stream
  (let [ping (atom nil)
        first-val (.-first (stream ping))]
    (reset! ping 1)
    (is (= 1 (await first-val)))))

(defprotocol NilExtension
  (-extenso [_]))

(extend-protocol NilExtension
  nil
  (-extenso [_] :nil)
  String
  (-extenso [_] :str))

(deftest extend-type-nil-works
  (is (= :str (-extenso "hello")))
  (is (= :nil (-extenso nil))))

(deftest wtf
  (let [a (atom 0)
        v (.substring "abc" 0 (swap! a inc))]
    (is (= @a 1))
    (is (= v "a"))))

(deftest dart-record-literal-are-working
  (is (dart/is? #dart(1) Record))
  (is (dart/is? #dart(1 .name "name") Record))
  (is (dart/is? #dart(.name "name") Record))
  (is (dart/is? #dart() Record)))

(deftype ^:abstract TestingResolveTypeUnresolveType []
  (^#/(String .bar String -> int) method1 [_ _])
  (^#/[String .bar String] method2 [_ _]))

(deftest dart-record-and-function-correctly-inferred
  (let [obj (reify :extends TestingResolveTypeUnresolveType
              :no-meta true
              (method1 [_ f] f)
              (method2 [_ r] r))]
    (is (= 10
          ((.method1 obj (fn ^int [^String one ^String .bar] (+ (.-length one) (.-length bar)) ))
           "hello"
           .bar "world")))
    (is (= #dart ("hey" .bar "foo") (.method2 obj #dart ("hey" .bar "foo"))))))

(deftest inst-literals-in-code
  (is (= 1978 (.-year #inst "1978-10-11"))))

(defprotocol IMethodsSupportDestructuring
  (-method-destructuring [this arg]))

(deftest methods-implementing-protocols-can-use-destructuring
  (is (= (-method-destructuring (reify IMethodsSupportDestructuring
                                  (-method-destructuring [this [one two]] (str one two)))
           ["Hello " "World!"])
        "Hello World!")))

(deftest for-cons-is-not-a-subtype-of-type-null
  (= 32686752 (reduce + (for [i (range 128) j (range i)] (* i j)))))

(deftest workaround-dartlang-52904
  (is (= :ok (let [x (identity 42)]
               (> x 0)
               :ok))))

(deftype MutableBox [^:mutable fld])

(deftest set!-eval-once
  (let [obj (MutableBox nil)
        x (.-fld! obj (MutableBox nil))]
    (is (identical? x (.-fld obj)))))

(deftest deep-set!
  (let [obj (MutableBox (MutableBox (MutableBox nil)))]
    (-> obj .-fld .-fld (.-fld! 1))
    (is (= 1 (-> obj .-fld .-fld .-fld)))))

(deftest testing-set!-prop-not-properly-casted-265
  (let [f (fn [^#/(Map String List) m]
            (let [v (. m "[]" "key")]
              (.-first! v "val")
              (.-first v)))]
    (is (= "val" (f (doto (#/(Map String List)) (. "[]=" "key" #dart ["hey"])))))))

(deftest testing-case-on-bool-working
  (let [t (identity true)
        f (identity false)]
    (is (false? (case t
                  true false
                  false true)))
    (is (true? (case f
                 true false
                 false true)))))

(deftest test-dissoc!-on-datascript-record-extension-failure
  (let [m {:as :aka, :default nil, :name :aka, :pattern nil, :recursion-limit nil, :recursive? nil, :reverse? nil,
           :xform nil, :multival? true, :ref? nil, :component? nil, :limit 1000}]
    (is (= {:as :aka, :default nil, :name :aka, :pattern nil, :recursion-limit nil, :recursive? nil, :reverse? nil,
            :xform nil, :multival? true, :ref? nil, :component? nil}
          (-> m transient (dissoc! :limit) persistent!)))))

(deftest magicasting-to-function-types-with-parameters
  (is (= "y" (.replaceAllMapped "x" "x" (constantly "y")))))

(deftest dont-magicast-to-function-types-with-empty-parameters-list
  (is (= "Hello"
        (await (Future.delayed (Duration .microseconds 1) (constantly "Hello"))))))

(deftest dont-magicast-to-function-types-without-parameters
  (is (try
        (Function.apply (identity str) ["abc" "def"])
        false
        (catch TypeError e
          (or (.contains (str e) #" is not a subtype of type 'Function' in type cast")
            (throw e))))))

(deftest test-reify-type-properly-inferred
  ;; check that this form compiles correctly
  ;; the inference of the type of this if used to create a compilation error
  (is (do (.write (if (identity true)
                    (reify :no-meta true StringSink (write [_ _]))
                    (StringBuffer "i")) "tactac")
          true))
  (is (do (.write (if (identity true)
                    (reify StringSink (write [_ _]))
                    (StringBuffer "i")) "tactac")
          true)))

(deftest test-async-error-handler
  (let [completer (dart:async/Completer)
        fut (binding [*async-error-handler*
                      (fn [e st]
                        (.complete completer e))]
              (Future/microtask #(throw :from-async)))]
    (is (not (.-isCompleted completer)))
    (is (= :from-async (await (.-future completer))))))

(deftest nil-is-not-a-set-but-disj-must-work
  (is (not (set? nil)))
  (is (nil? (disj nil :a))))

(deftest dart-lists-obey-print-readably
  (is (= "[\"hello\"]" (pr-str #dart ["hello"]))))

(deftest nested-case-dart-closure-case-dont-throw-becasue-of-over-captured-default-label
  (is (case (rand)
        :a false
        :b (fn []
             (case (rand) :c false false))
        true)))

(deftest nil-as-test-expression-in-when-some
  (is (nil? (when-some [x nil] 42))))

(deftest throw-when-passing-a-nullable-fn-instead-of-a-non-nullable-fn
  (let [f (fn [^^{:fn-type {:fixed-params-types [dynamic]
                            :ret-type bool}} Function? f ^Iterable l]
            (.any l f))]
    (is (thrown? Error (f nil [1])))))

(deftest print-level-print-length
  (is (= "[[[# 7] 8] 9]" (binding [*print-level* 3] (pr-str (reduce vector (range 10))))))
  (is (= "{{{# 7} 8} 9}" (binding [*print-level* 3] (pr-str (reduce hash-map (range 10))))))
  (is (= "(0 1 2 ...)" (binding [*print-length* 3] (pr-str (range 10)))))
  (is (= "{0 1, 4 5, 6 7, ...}" (binding [*print-length* 3] (pr-str (apply hash-map (range 10)))))))

(deftest iterator-on-pv-returns-pviterator
  (is (dart/is? (iterator [1 2]) cljd.core/PVIterator)))

(deftest doseq-handles-await-like-a-charm
  (let [out (atom [])]
    (doseq [d (range 3)]
      (await (future nil))
      (swap! out conj d))
    (is (= [0 1 2] @out))))
